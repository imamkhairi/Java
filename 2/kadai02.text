以下の課題のレポートは, レポートファイルreport02.txtを作成してアップロードにより提出すること. ただし, 課題1のみ紙での提出となるので注意のこと. A4用紙に手描きして, 出席番号・名前・テーマ番号を記入し, 情報棟3階天元ポストへ提出すること.

    今回の預金口座プログラムについて, main関数におけるメモリの様子を図に描き表せ. 変数を箱で表し, さらにポインタを, 箱と箱をつなぐ矢印で表現せよ. なお, 変数の具体的なアドレス(16進数)は調べることができないため, 記入不要である. (紙に手描きして提出)

    準備: A4用紙の向きは縦で, まず上部に「4J 出席番号 名前 テーマ02 課題1レポート」と書く.

    ヒント: 「ポインタ(pointer)」とは, 「ポイント(point)するもの(er)」, すなわち, 他の変数を指し示す変数の意である.

    ヒント: 「構造体」とは, 複数の変数を, 連続したメモリにひとまとめに配置したものである. 絵的には, 一つの大きな箱の中に, 複数の小箱が入っている様子をイメージすると良い.

    struct Koza      /* 預金口座構造体 */
    {
      double riritsu; /* 利率 */
      int gankin;     /* 元金 */
    };

    注意: my_koza->gankin等の見た目にだまされない様に注意. この「->」をそのまま矢印に置き換えて描いたのでは, 正確ではない. my_kozaは直接gankinは指さない.

    注意: 今回の図に関数は不要. kotae等のローカル変数も不要. 登場するのはriritsu, gankin, my_kozaの三つのみ. 矢印も一つのみ.

    知識: Java版のmain関数のmy_kozaには「*」(アスタリスク)が付いていないが, 実は, C言語版と同じポインタである. Javaではこれを「参照(リファレンス)」と呼ぶ.
    今回のJavaプログラムを, 元金をコマンドライン引数から入力できるように改造せよ. (ソース KozaApp2.java を作成し, レポートファイルに貼付け, 実行方法と実行結果も貼付け)

        ソースファイルのコピー方法の例
        $ cp KozaApp.java KozaApp2.java

        ファイル名を変更したので, ソース中に書いてあるクラス名も「KozaApp2」に変更する. 修正漏れに注意のこと. なお, mainしか変更しないので, Koza.java側の修正は不要である.

        実行方法の例     ↓これがコマンドライン引数
        $ java KozaApp2 100000

        コマンドライン引数は配列argsに, 0番から順に格納されている. つまり, 実行時にコマンドライン引数から与えた元金は, args[0]に格納されている. ただし, 文字列型であり, 整数型ではない.
        文字列を整数に変換するには, 「Integer.parseInt( )」という関数を使う. この関数の引数に文字列を一つ与えると, 整数型に変換されて返ってくる. それを元金の変数に代入すると良い.
        String型の解説: C言語では文字列型という型は存在せず, \0で終わる, 文字の配列であった. これに対し, Javaでは, 予め文字列型であるStringクラスが用意されており, 文字列を, 配列ではない, 一つの変数として扱える. Javaのmain関数のargsは, この文字列型の, 配列である. → String型はテーマ08で, 配列はテーマ10で正式に扱う予定.

        現時点では「JavaのString型」==「C言語のchar*型」と考えて良い. どちらも「文字列型」.

    C言語のmain関数では, 関数の引数として, コマンドライン引数の個数であるargcと, コマンドライン引数の配列であるargvの両方が与えられていた. これに対し, Java版では, コマンドライン引数の配列であるargsしか書かれていない. このことから, Javaの配列には, C言語の配列にはない, 何か重要な情報が隠されていると考えられる. どの様な情報が隠されているか, 推測せよ. (レポートファイルに記入)

                  int  main(int argc, char *argv[])       /* C言語版. 引数が二つある.     */
    public static void main(String args[])                /* Java版.  引数が一つしかない. */

    ヒント: まずC言語のコマンドライン引数について思い出し(または調べ), コマンドライン引数をprintf("%s\n", argv[i]);で全て表示するプログラムを作成してみると良い. 以下の例ではargv[0]に"./a.out"が, argv[1]に"4J"が, argv[2]に"27"が, argv[3]に"TENMOTO"が入っていることが確認できる.

    C言語でこの↓動作をするプログラムを作ると良い.
    $ ./a.out 4J 27 TENMOTO
    ./a.out
    4J
    27
    TENMOTO

    ヒント: その後, Javaで同じ様にコマンドライン引数を全て表示させようとすると, 何かが足りないことに気づくはず. それが答えであり, argsという配列変数に隠されているものである.

    ヒント: C言語のargvは「『文字の配列』の配列」である. Javaのargsは「文字列の配列」である. C言語の「文字の配列」は「文字列」に相当するから, argvとargsについては, 実質的にC言語でもJavaでも同じである. → ではそれ以外で異なる所は?
    C言語版のKoza_risoku関数の引数にある「struct Koza *koza」や, kekkaの計算式中の「koza->」が, Java版では不要で, とてもシンプルな記述となっている. その理由を推測せよ. (レポートファイルに記入)

    ヒント: Java版のプログラムの中で, risoku関数がある場所と, その周り(外側)の位置関係を眺めてみると良い.

    ヒント: 「class Koza」の開き中括弧「{」と閉じ中括弧「}」の場所を調べてみよう.
    これまでの課題より, Javaにおける「クラス(class)」とはどういうものか, 推測せよ. (レポートファイルに記入)

    注意: 現時点でどの様に推測するか, 自分でどう考えるか, が大切なので, 教科書やネットを調べて正解(正確な定義)を答えるのが目的ではない.

    ヒント: 構造体のメンバ変数がある場所, 関数がある場所, クラスの中括弧{ }の場所
    Java版の預金口座プログラムを, さらに自由に改造してみよ. 特に何も思い浮かばなければ, 3カ月の箇所を, ループで1カ月～36カ月に変化させてみよ. ファイル名・クラス名はKozaApp3とする. (ソース, 実行方法と実行結果, 改造した点, 改造してみた感想をレポート)

    注意: ファイル名と同時に, ソース中に書いてあるクラス名も「KozaApp3」に変更する必要がある. 修正漏れに注意のこと.

    アドバイス: for文やif文, while文などの基本的な文法はC言語と同じであるから, C言語で学習した様々な技術を試してみると良い. Javaの教科書も活用すると良い.
