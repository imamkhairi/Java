<!--?xml version="1.0" encoding="utf-8"?-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>プログラミング言語IIIA(Java) テーマ06</title>
<link rel="stylesheet" href="%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E8%A8%80%E8%AA%9EIIIA(Java)%20%E3%83%86%E3%83%BC%E3%83%9E06_files/tenmo2008single.css" type="text/css" media="all">
</head>

<body>

<h2>プログラミング言語IIIA(Java) テーマ06</h2>

<h3>内容</h3>

<p>前回に引き続き, オブジェクト指向的な「通常のメソッド」と手続き指向的な「<code>static</code>メソッド」の違いを体験的に学習し, さらに理解を深め, 両方とも使いこなせる様になる.</p>

<h3>通常のメソッドと<code>static</code>メソッドの違い</h3>

<p>以下に, 通常のメソッドと<code>static</code>メソッドの違いを理解するための例題プログラムを示す. このプログラムは釧路高専生をモデル化したものであり, 二つの学生紹介メソッドが含まれている. 通常版はオブジェクト指向的なメソッドであり, <code>static</code>版は手続き指向的(C言語的)なメソッドとなっている. 双方の違いをしっかり読み取って欲しい.</p>

<pre>class Student
{
    int gakunen;   // 学年 1〜5の整数
    String bunnya; // 分野 "情報", "機械", "電気", "電子", "建築"のいずれかの文字列
    String namae;  // 名前 文字列

    // コンストラクタは課題にて自作

    void shokai() // 通常版
    {
        // gakunen, bunnya, namaeはthis(主たるインスタンス)のフィールドを使う.
        System.out.println("私は" + this.gakunen + "年" + this.bunnya + "の" + this.namae + "です.");
    }
    static void shokai(Student a) // static版
    {
        // gakunen, bunnya, namaeは引数aのフィールドを使う.
        System.out.println("彼は" + a.gakunen + "年" + a.bunnya + "の" + a.namae + "さんです.");
    }
}
</pre>

<pre>class StudentApp
{
    public static void main(String[] args)
    {
        Student jotaro = new Student(4, "情報", "じょうたろう");
        Student josuke = new Student(3, "情報", "じょうすけ");
        jotaro.shokai(); // 通常版メソッドを呼び出す
        josuke.shokai(); // 通常版メソッドを呼び出す
        Student.shokai(jotaro); // static版メソッドを呼び出す
        Student.shokai(josuke); // static版メソッドを呼び出す
    }
}
</pre>

<p>上記の例題プログラムの実行結果を以下に示す. 「私」と「彼」の違いに注目して欲しい.</p>

<pre>私は「4年情報」の「じょうたろう」です.
私は「3年情報」の「じょうすけ」です.
彼は「4年情報」の「じょうたろう」さんです.
彼は「3年情報」の「じょうすけ」さんです.
</pre>

<ul>
<li><code>jotaro.shokai();</code>を実行するとき, CPUは「じょうたろう」になりきって<em>自己</em>紹介している.</li>
<li><code>josuke.shokai();</code>を実行するとき, CPUは「じょうすけ」になりきって自己紹介している.</li>
<li><code>Student.shokai(jotaro);</code>を実行するとき, CPUは<em>客観的</em>に「じょうたろう」を紹介している.</li>
<li><code>Student.shokai(josuke);</code>を実行するとき, CPUは客観的に「じょうすけ」を紹介している.</li>
</ul>

<!--
<h3>関数名のオーバーロード</h3>

<p>コンストラクタの回でも触れたように, JavaではC言語と異なり, 引数の型や個数が違えば, <em>同じメソッド名</em>を重複して利用できる. 上記の例では<code>shokai</code>というメソッド名に, 二つの異なる内容を持たせている. このことを, 荷物(load)の積み過ぎ(over)に例えて, メソッドの<em>オーバーロード</em>(overload)と呼ぶ. ※注意: 大さん主(overlord)ではない.</p>
-->

<h3>課題</h3>

<p>以下の課題のレポートは, レポートファイル<code class="em">report06.txt</code>を作成してアップロードにより提出すること.</p>

<p><em>[注意]</em> 今回の課題はすべて上記の例題プログラムをもとに<em>追加</em>していく形式で行う. 各課題が終了した段階で, 必要な項目をレポートファイルに貼付けていくこと. 全ての課題が終わってから「最終的なソースしか残っていない」という状況とならないよう注意すること.</p>

<ol>

<li>今回の課題用ディレクトリを作成し, 上記の例題プログラムを実行せよ. <em>コンストラクタ</em>は自分で作成して追加せよ. 学年・分野・名前の値やオブジェクト変数名は適切に<em>変更</em>すること. (レポート不要<!--コンストラクタ部分のソースと, コンストラクタ部分の動作説明をレポート-->)
  <ul>
  <li>「<code>Student jotaro = new Student(4, "情報", "じょうたろう");</code>」等がコンパイルに通る様に, コンストラクタを自分で作成する. 引数は整数・文字列・文字列の3つである.
<pre>// コンストラクタのヒント
Student(int gakunen, 他2つ) {
    this.gakunen = gakunen; // 左辺をthis.で始める
    他2つも同様
}
</pre></li>
    <li>学年・分野・名前やオブジェクト変数名を, 自分の趣味や興味に合わせて架空の人物に<em>必ず変更</em>すること. 例題そのままでは不可とする.</li>
  <!--<li>学年は1～5の整数, 分野は"機械", "電気", "電子", "情報", "建築"のいずれかの文字列, 名前も文字列とする.</li>-->
  <!--<li>動作説明では, <code>main</code>からどの値がコンストラクタのどの引数に渡され, それらがどのフィールドに保存されるか, について書くこと.</li>-->
  </ul>
  </li>

<li>高専生クラスのフィールドに<code>String</code>型の「住居」(フィールド名<code>jukyo</code>)を追加し, それに応じてコンストラクタや紹介メソッド, <code>main</code>メソッドを修正せよ. 以下に実行結果の例を示す. 住居の値は<em>"自宅"</em>, <em>"学寮"</em>, <em>"下宿"</em>のいずれかの文字列とする. (この段階での<em>プログラム全体</em>及び実行結果<!--, 動作の説明-->をレポート)
<pre>私は「4年情報」の「じょうたろう」です. 私の住居は「下宿」です.
私は「3年情報」の「じょうすけ」です. 私の住居は「学寮」です.
彼は「4年情報」の「じょうたろう」さんです. 彼の住居は「下宿」です.
彼は「3年情報」の「じょうすけ」さんです. 彼の住居は「学寮」です.
</pre>

<ul>
<li>住居の取り得る値が三つしかないのが気に入らないと思うが, そこは我慢して欲しい. →課題5にてご自由に</li>
</ul>

</li>

<!--<ul>
<li>必ず動作の説明を記入すること(コンストラクタについては今回は書かなくて良い). <code>main</code>から<code>shokai</code>メソッドが呼び出されると, どのインスタンスの, どのフィールドの値が表示される, の様に, 処理の流れを追う文章を書くこと.</li>
<li>通常版と<code>static</code>版の動作の違いについても書くこと.</li>
</ul>-->

<!--
<li>高専生クラスに, 「○○と○○は友人です」と表示する(メソッド内で表示するだけ)の友人宣言メソッド<code>yujin</code>を, 通常版と<code>static</code>版の2通り追加し, それに応じて<code>main</code>メソッドにも呼び出しコードを追加せよ. 以下に実行結果の例を示す. (<em>追加した部分</em>のソースと実行結果, 通常版と<code>static</code>版の動作の違いをレポート)
<pre>
私「じょうたろう」は「じょうすけ」さんと友人です.
「じょうたろう」さんと「じょうすけ」さんは友人です.
</pre>
    <ul>
    <li>通常版 ... 引数は高専生クラスのインスタンス<em>一つ</em></li>
    <li><code>static</code>版 ... 引数は高専生クラスのインスタンス<em>二つ</em></li>

    </ul></li>
-->

<li>高専生クラスに, <em>住居が同じ</em>内容かどうかで判定する仲間判定メソッド<code>hantei</code>を, 通常版と<code>static</code>版の2通り追加し, それに応じて<code>main</code>メソッドにも呼び出しコードを追加せよ. 判定結果は「仲間である」「仲間でない」のどちらかとする(メソッド内で表示するだけ). 以下に実行結果の例を示す. 2通りの判定結果をテストするために, 3人目の人物を登場させること. (<em>追加した部分</em>のソースと実行結果, 通常版と<code>static</code>版の動作の違いをレポート)
<pre>私は「4年情報」の「じょうたろう」です. 私の住居は「下宿」です.

私は「3年情報」の「じょうすけ」です. 私の住居は「学寮」です.
私「じょうすけ」と「じょうたろう」さんは仲間ではありません.
「じょうすけ」さんと「じょうたろう」さんは仲間ではありません.

私は「3年機械」の「きかいたろう」です. 私の住居は「学寮」です.
私「きかいたろう」と「じょうすけ」さんは仲間です.
「きかいたろう」さんと「じょうすけ」さんは仲間です.
</pre>
    <ul>
      <li>住居で仲間判定するのは気に入らないと思うが, そこは我慢して欲しい. →課題5にてご自由に</li>
      <li>二つの文字列が同じ<em>内容</em>かどうか判定するには, <code>String</code>クラスの<code class="em">equals</code>メソッドを用いる.</li>
      <li><code>==</code>ではアドレス(参照)の比較となり, 内容での<em>正しい比較が保証されない</em>.
<!--
<li><code>String</code>クラスのより詳細な機能を知りたい人は, 教科書やJava2 API仕様を調査してみて欲しい. (<code>String</code>クラスは次回, 詳細に扱う予定.)</li>
-->
<pre>if (str1.equals(str2)) // 正しい使い方
{
    // str1とstr2が同じ内容かどうかを比較する.
}
</pre>
<pre>if (str1 == str2) // 誤った使い方
{
    // str1とstr2が同じ場所を指しているかどうかを比較する.
    // 同じ内容であっても, 異なるインスタンスであればアドレスが異なるため, 成り立たない.
}
</pre></li>
    <!--<li>動作の説明には, コンストラクタについては書かなくて良いので, 仲間判定メソッドについて, 十分に書くこと.</li>-->
    <!--<li>通常版と<code>static</code>版の動作の違いについても書くこと.</li>-->
    <li>通常版と<code>static</code>版の<code>hantei</code>メソッドの<em>動作の違い</em>について説明文を書くこと. 「通常版では<code>main</code>から<code>hantei</code>メソッドが呼び出されると, ○○インスタンスと○○インスタンスの, △△フィールドの値が比較される. 一方<code>static</code>版では〜」の様に, 処理の流れを追う文章を書くこと. ○○には「主となる」や「一つめの引数の」などの言葉を入れること.</li>
    </ul>
</li>

<li>高専生クラスに, <em>フィールド</em>の学年の値を<code>+1</code>して<em>更新</em>する進級メソッド<code>shinkyu</code>を, 通常版と<code>static</code>版の2通り追加し, それに応じて<code>main</code>メソッドにも呼び出しコードを追加せよ. 進級したことを表すお祝いメッセージも表示するようにすること. (<em>追加した部分</em>のソースと実行結果, 通常版と<code>static</code>版の動作の違いをレポート)
    <ul>
    <li>進級した様に見えるだけだったり, 進級メソッドが終了したら元の学年に戻ってしまったりしないか, 良く確認する.
<pre>// 残念な例. 上がったつもりが, 実は上がっていない.
void shinkyu()
{
    System.out.println("私は" + (this.gakunen + 1) + "年に進級しました!");
}
</pre></li>
    <li>進級メソッド呼び出し後に, 自己紹介させて確認してみること.</li>
    <li>同一のインスタンスに対して通常版と<code>static</code>版の両方で呼び出すと2学年進んでしまうので, 一人を通常版, 別のもう一人を<code>static</code>版で進級させてみると良い.</li>
    <!--<li>動作の説明には, コンストラクタの詳細は書かなくて良いので, 進級メソッドについて, 十分に書くこと.</li>-->
    <li>通常版と<code>static</code>版の動作の違いについても書くこと.</li>
    </ul>
</li>

<li>今回の高専生クラスを参考にして, 自由にクラスを作成してみよ. ただし, <em>フィールド</em>として何らかの属性を持ち, <!--進級メソッドの様に, -->メソッド呼び出しによりそれらの属性の<em>値が更新される</em>内容とすること. 通常のメソッドのみで良い(つまり<code>static</code>メソッドは作らなくて良い). 今後も何度も自由課題があるため, <!--条件を満たせば, -->今回のレポート締切に間に合う様な<em>規模の小さい</em>クラスで十分である. (ソース, 実行結果, <em>解説</em>をレポート)
    <ul>
    <li>自分の身の回りの物事や, 趣味, 興味がある事柄で良い.</li>
    <li>必ずメソッド呼び出しにより<em>フィールドの値が更新される</em>ように作成すること.</li>
    <li>例: RPGでのレベルアップ時の処理(Lvが1上がり, HP, MPがそれぞれ1〜6の範囲でランダムに上昇するなど)</li>
    </ul>
</li>

</ol>

<h3>レポート</h3>

<ul>
<li>内容: 課題中に指示されている通り. 必要な項目を全て記載しているか, 十分に確認すること.</li>
</ul>



</body></html>