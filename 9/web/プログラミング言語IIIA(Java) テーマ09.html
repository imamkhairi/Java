<!--?xml version="1.0" encoding="utf-8"?-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>プログラミング言語IIIA(Java) テーマ09</title>
<link rel="stylesheet" href="%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E8%A8%80%E8%AA%9EIIIA(Java)%20%E3%83%86%E3%83%BC%E3%83%9E09_files/tenmo2008single.css" type="text/css" media="all">
</head>

<body>

<h2>プログラミング言語IIIA(Java) テーマ09</h2>

<h3>内容</h3>

<p>Javaで配列を扱う方法を学ぶ.</p>

<p>C言語と同様に, メモリブロックの「先頭アドレス」や「参照(ポインタ)」という考え方は登場するものの, <code>&amp;</code>演算子(変数のアドレスの取得)や<code>*</code>演算子(ポインタ変数が指している先の値の取得), <code>++</code>演算子(ポインタ変数の加算), <code>--</code>演算子(ポインタ変数の減算)などの<em>ポインタ演算ができない</em>安全な仕様であるため, C言語の配列よりも理解や利用が容易であるので安心して欲しい.</p>

<h3>基本型の配列</h3>

<ul>

<li>基本型とは, <code>int</code>や<code>double</code><!--, <code>char</code>, <code>boolean</code>(真偽値, 値は<code>true</code>か<code>false</code>のどちらか)-->等の値を「一つ」格納できる変数の型である.</li>

<li>配列は<em>メモリブロック</em>であり, インスタンスと同様に<code class="em">new</code>演算子で生成する. <code>new</code>演算子は配列の<em>先頭アドレス</em>を返すので, それを配列型の変数(配列変数)に保存しておき, <code class="em">[ ]</code>演算子で各要素にアクセスする.</li>

<li><code>new</code>演算子で配列を生成する際は, <!--単純に--><em>要素数</em>を指定する.<!-- (C言語の様に要素1個分のサイズの指定は不要.)C言語の<code>malloc</code>関数のように, <code>(</code>要素1個分の大きさ x 要素数<code>)</code>を計算して与える必要はない. →C言語については<a href="../01/">テーマ01</a>の課題3-1参照--></li>

<p>※配列の「要素」「要素の番号」「要素数」「配列変数」をしっかり区別すること!</p>

<p>※ひとつひとつの「要素」のことを, 「配列」と呼ばないこと!</p>

<p>※<em>【大切な事なのでもう一度】</em> ひとつひとつの「要素」のことを, 「配列」と呼ばないこと!!</p>

<!--<li>Javaの配列は, C言語における<code>malloc</code>関数や<code>calloc</code>関数で生成する動的配列に相当する.</li>-->

<pre>// 例: int型10個の要素から成る配列
int[] a;         // int型の配列変数aを宣言. この段階では矢印の根本のみ. まだメモリブロックはない.
a = new int[10]; // int型10個分のメモリブロックを割り当て, その先頭アドレスをaに代入.
                 // これによりaの矢印がメモリブロックの先頭を指すようにつながる.

a[0] = 314;      // [ ]演算子で各要素にアクセスできる. 0番が先頭である.
a[1] = 271;
...
a[9] = 256;      // この場合, 使えるのは9番まで.
                 // 10番にアクセスすると実行時エラーとなり, ArrayIndexOutOfBoundsExceptionが出る.
                 // つまり要素の番号が, 使える範囲を超えてしまう.
</pre>

<img src="%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E8%A8%80%E8%AA%9EIIIA(Java)%20%E3%83%86%E3%83%BC%E3%83%9E09_files/2006.png" width="320">

<li>配列の要素数は, 配列変数の<code class="em">length</code>フィールドで取得できる(フィールドなので括弧が付かない).<!-- これに対して文字列の場合は<code>length</code>メソッドなので, 括弧が付く. 違いに注意). →文字列型については<a href="../07/">テーマ07</a>参照--></li>

<pre>int n = a.length; // nに10が代入される. lengthに( )は付けない. 
</pre>

</ul>

<h3>オブジェクトの配列</h3>

<ul>

<li>基本型の配列では変数の<em>値</em>がそのまま格納されるが, オブジェクトの配列では, 各要素にはインスタンスへの<em>参照(ポインタ)</em>が格納される.</li>

   <p>※つまり正確には「<em>オブジェクト変数の配列</em>」と考えるのが正しい.<!-- オブジェクトそのものが並んでいるわけではない.--></p>

<li><!--重要な特性: -->オブジェクトの配列の各要素には, 配列の生成時に指定したクラスのインスタンスへの参照のみならず, そのクラスを<em>継承</em>したクラスのインスタンスへの参照も代入できる.</li>

<pre>// 例: 曲データの配列
Song        song_a = new Song(〜);
Song        song_b = new Song(〜);
Song        song_c = new Song(〜);
KaraokeSong song_d = new KaraokeSong(〜); // この曲データのみ歌詞の文字列付き

Song[] a;         // Song型の配列変数aを宣言. 
a = new Song[10]; // 参照(ポインタ)を10個格納できるメモリブロックを割り当てて, aから接続する.

a[0] = song_a; // a[0]の箱からsong_aにつながる.
a[1] = song_b; // a[1]の箱からsong_bにつながる. 以下同様.
a[2] = song_c; // aの要素にSong型を格納できるのは当り前だが,
a[3] = song_d; // KaraokeSong IS-A Songなので, KaraokeSong型も格納できる. これも継承の利点の一つ.
</pre>

<img src="%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E8%A8%80%E8%AA%9EIIIA(Java)%20%E3%83%86%E3%83%BC%E3%83%9E09_files/2006_002.png" width="320">

<!--<li>結果的に, 配列変数「<code>a</code>」から各インスタンスへのアクセスには<em>2回の参照</em>(矢印を2本たどること)が必要となり, 基本型における2次元配列と同様な2段階のメモリ構成となることに注意せよ.</li>-->

</ul>

<h3>課題</h3>

<p>以下の課題のレポートは, レポートファイル<code class="em">report09.txt</code>を作成してアップロードにより提出すること.</p>

<ol>

<li>基本型の配列: 以下の仕様を満たす, 整数の<em>配列リスト</em>クラスを作成せよ. 予め一定の大きさの配列を用意しておき, そこに<em>先頭から順に</em>要素を詰め込んで格納していく機能を持つクラスである. 動作をテストする<code>main</code>も作成すること. (ソース, 実行結果をレポートファイルに貼り付け)</li>
    <ul>
    <li><code>main</code>の例(これだけでは<!--動作テストは-->十分ではない)</li>
<pre>ArrayListInt a = new ArrayListInt();
a.add(314); a.add(217); a.add(173); // 三つの整数を格納し
a.print();                          // それらを全て表示する
</pre>
    <li>クラス名 ... <code>ArrayListInt</code></li>
    <li>フィールド</li>
        <ul>
        <li>このクラスに格納できる, <em>最大の要素数</em></li>
        <li>整数の配列変数 (ここではまだ<code>new</code>しない → コンストラクタの中で<code>new</code>すること)</li>
        <li><em>実際の要素数</em></li>
        </ul>
    <li>メソッド</li>
        <ul>
        <li>コンストラクタ ... <em>引数なし</em>. 「最大の要素数」に5を代入し, 「最大の要素数」の大きさの配列を生成する(<code>new</code>はここで行う). 「実際の要素数」はゼロにする.</li>
        <li>要素追加メソッド <code>add</code> ... 引数として<em>整数を一つ</em>受け取り, 現在までに格納されている要素の<em>最後</em>に
格納(代入)する. つまり, 最初に呼び出された際は0番に, 次に呼び出された際は1番に, その次に呼び出された際は2番に, 
という様に格納する. 一つ格納したら, 「実際の要素数」を1増やす. また, 既に要素がいっぱいで, これ以上追加ができない場合は, 
自作のエラーメッセージを表示する. 戻り値なし.</li>
        <p>ヒント: 配列の「実際の要素数」番に, 引数の整数を, 代入する.</p>
        <li>「実際の要素数」のゲッター <code>size</code> ... 「実際の要素数」を<code>return</code>するだけ</li>
	<li>要素のゲッター <code>get</code> ... 引数として<em>要素の番号</em>を受け取り, その要素を返す. ※要素「数」のゲッターではない.</li>
        <li>全要素表示メソッド <code>print</code> ... <em>実際に格納されている</em>すべての要素を<code>for</code>ループで表示する. 戻り値なし.</li>
        </ul>
	<li>以上の機能により, このクラスのユーザー(つまり<code>main</code>など, クラスの<em>外側</em>)からは, 追加した要素の分だけ自動的に大きくなっていく「要素のコレクション」として見える/使える.</li>
        <p>※必要ならば, 追加できる空きが無くなった場合に, より大きな配列を確保して, それまでに追加された内容を自動的にコピーする「配列拡張」機能を作成すれば良い. ただ, それは難しいので, この課題では作成する必要はない.</p>
	<!--    <li>また, クラスとしてまとめているため, クラスの内部でメモリが具体的にどのように使われているかは, ユーザーは知る必要がない. さらに, 公開されている(つまりpublicな)メソッドの引数や戻り値を変更しない限り, 配列をやめてSchemeの様な連結リスト構造にする等, クラスの内部を大幅変更しても, ユーザーには影響が少ない.</li>-->
	<form><fieldset>
	<legend>レポート自己チェックリスト</legend>
	<input type="checkbox" checked="checked">クラス, フィールド, コンストラクタ, メソッドの全てにpublic/privateを指定した.<br>
	<input type="checkbox" checked="checked">コンストラクタの引数を「なし」にした.<br>
	<input type="checkbox" checked="checked">フィールドで<code>new</code>をせずに, コンストラクタの中で<code>new</code>をした.<br>
	<input type="checkbox" checked="checked">「最大の要素数」以上の追加を試みると, 自作のエラー文が表示されることを確認した.<br>
	<input type="checkbox" checked="checked">ソース, 実行結果を載せた.<br>
	
    </fieldset></form></ul>

</ol>
<ol start="2">

<li>オブジェクトの配列: 以下の仕様を満たす<em>学級</em>クラスを作成せよ. 動作をテストする<code>main</code>も作成すること. <code>main</code>では通学生と寮生の両方を追加すること(スーパークラスである「高専生」は追加しない). (ソース, 実行結果をレポートファイルに貼り付け)</li>
    <p>準備: <a href="http://jsuri1.info.kushiro-ct.ac.jp/~tenmo/java/08/">テーマ08</a>の課題4までで作成した高専生クラス, 通学生クラス, 寮生クラスの自己紹介メソッドの名前が「<code>shokai</code>」等, <em>すべて同じ</em>に統一されていることを確認せよ. もし異なる場合は修正しておくこと.</p>
    <ul>
    <li>クラス名 ... <code>ClassRoom</code></li>
    <li>フィールド</li>
        <ul>
        <li>この学級に格納できる, 最大の人数</li>
        <li><em>高専生</em>クラスの配列変数 (ここではまだ<code>new</code>しない → コンストラクタの中で<code>new</code>すること)</li>
        <li>実際の人数</li>
        </ul>
    <li>メソッド</li>
        <ul>
        <li>コンストラクタ ... <em>引数なし</em>. 「最大の人数」に5を代入し, 「最大の人数」の大きさの配列を生成する(<code>new</code>はここで行う). 「実際の人数」はゼロにする.</li>
        <li>高専生追加メソッド <code>add</code> ... 引数として<code>Student</code>型の<em>高専生を一人</em>まるごと受け取り, 現在までに格納されている高専生の<em>最後</em>に格納(代入)する. 一人格納したら, 「実際の人数」を1増やす. また, これ以上追加ができない場合は, 自作のエラーメッセージを表示する. 戻り値なし.</li>
        <li>「実際の人数」のゲッター <code>size</code> ... 「実際の人数」を<code>return</code>するだけ</li>
        <li>高専生のゲッター <code>get</code> ... 引数として<em>高専生の番号</em>を受け取り, その<em>高専生</em>をまるごと返す. ※高専生の「名前」のゲッターではない(つまり戻り値の型が<code>String</code>では正しくない).</li>
        <li>全自己紹介メソッド <code>shokai</code> ... <em>実際に格納されている</em>すべての高専生に対して, <code>for</code>ループで<em>自己紹介</em>させる. 「紹介してあげる」のではないことに注意. 戻り値なし.</li>
        </ul>
	<form><fieldset>
	<legend>レポート自己チェックリスト</legend>
	<input type="checkbox" checked="checked">クラス, フィールド, コンストラクタ, メソッドの全てにpublic/privateを指定した.<br>
	<input type="checkbox" checked="checked">コンストラクタの引数を「なし」にした.<br>
	<input type="checkbox" checked="checked">フィールドで<code>new</code>をせずに, コンストラクタの中で<code>new</code>をした.<br>
	<input type="checkbox" checked="checked"><code>main</code>で, 通学生と寮生の両方を登場させ, 学級に追加した.<br>
	<input type="checkbox" checked="checked"><code>main</code>で, スーパークラスである「高専生」は追加していない.<br>
	<input type="checkbox" checked="checked">「最大の人数」以上の追加を試みると, 自作のエラー文が表示されることを確認した.<br>
	<input type="checkbox" checked="checked">ソース, 実行結果を載せた.<br>
	
    </fieldset></form></ul>

    <!--
	 <li>課題2の学級クラスに, 高専生の削除メソッドを追加せよ. 動作テストも行うこと. (<em>追加・変更箇所</em>のソース, 実行結果, ***動作の説明***をレポート)</li>
	 <ul>
	 <li>高専生削除メソッド ... 引数として高専生の番号を受け取り(番号は0から開始), それ以降の高専生をすべて一つ前に<em>移動</em>させる. 一番後ろの高専生が入っていた要素には, <code>null</code>を代入する. 戻り値なし.</li>
	 <form><fieldset>
	 <legend>レポート自己チェックリスト</legend>
	 <input type="checkbox">高専生削除メソッドの動作テストを行った.</input><br />
	 <input type="checkbox">ソース, 実行結果を載せた.</input><br />
	 <input type="checkbox">ソースは追加・変更箇所のみ載せた.</input><br />
	 </form>
	 </ul>
    -->

    <li>課題2の全自己紹介メソッドでは, 「高専生クラス」の配列の要素一つ一つに対して<code>shokai</code>メソッドを呼び出しているのだから, 「高専生クラス」の<code>shokai</code>メソッドが実行されると予想される. ところが, 実際には<em>そうではない</em>実行結果となる. <em>その実行結果</em>と, <em>その機能の呼び名</em>を調査して報告せよ. (レポートファイルに記入)

    <ul>
    <li>ヒント: 教科書11.3節 p.356〜p.363</li>
    </ul></li>

    </ol>

<!--
<ol start="4">

<li>課題3までの学級クラスに, 最大人数のゲッターおよびセッターを追加せよ. 動作テストも行うこと. (<em>追加・変更箇所</em>のソース, 実行結果, 動作説明をレポート)</li>
  <ul>
  <li>「最大の人数」のゲッター ... <code>return</code>するだけ</li>
  <li>「最大の人数」のセッター ... 引数として「新しい最大の人数」を受け取り, その大きさの新しい配列を生成し, 元の配列に入っていた高専生を新しい配列にコピーする. その後, 配列の参照を新しい配列に切り替え, 「最大の人数」を更新する. 戻り値なし.</li>
    <ul>
    <li>簡単のため, 「最大の人数」は増えると想定して良い. → 元の配列に入っていた高専生は, 全員そのまま新しい配列にコピーできる.</li>
    <li>「最大の人数」が増える場合 ... 元の配列に入っていた高専生を全員そのまま新しい配列にコピーする.</li>
    <li>「最大の人数」が減る場合 ... 元の配列に入っていた高専生を, 先頭から順に「新しい最大の人数」分だけ, 新しい配列にコピーする. ※入りきらない高専生は残念ながら...</li>
    </ul>
<form><fieldset>
<legend>レポート自己チェックリスト</legend>
<input type="checkbox">元の配列に入っていた全ての高専生を, 新しい配列にコピーした.</input><br />
<input type="checkbox">コピーする際は「最大の人数」が増えた場合と減った場合の2通りに分けた.</input><br />
<input type="checkbox">配列の参照を, 元の配列から新しい配列へ切り替えた.</input><br />
<input type="checkbox">「最大の人数」が増えた場合と減った場合の両方の動作テストを行った.</input><br />
<input type="checkbox">ソース, 実行結果, 動作説明を載せた.</input><br />
<input type="checkbox">ソースは追加・変更箇所のみ載せた.</input><br />
<input type="checkbox">動作説明には「最大の人数のセッター」を重点的に, 処理の流れを5行程度を目安に書いた.</input>
</form>
  </ul>

</ol>
-->

<ol start="4">

<li>配列の添字(要素の番号)操作やポインタ演算によるメモリアクセスの危険性について, C言語とJavaでどの様に異なるか, 
比較して考察せよ. 調査に用いた文献情報(著者・図書名・出版社・出版年・ページ範囲)を必ず示した上で, 自分でまとめ直すこと. 
ネットで調べても良いが, その場合はURLを示し, 必ず「実際に実行」してその結果を確認してみること. (レポートファイルに考察, 文献情報, 
URL, ソース, 実行結果を記入)</li>

<p>ヒント: C言語で<code>[ ]</code>演算子の中の要素番号や, <code>&amp;</code>, <code>*</code>, ポインタ変数の<code>++</code>や<cod>--を間違って(または意図的に悪意を持って)使うと, どの様な不具合が起こるか・起こせるか, 考えてみよ. また逆に, Javaではそれができるかどうか, 考えてみよ.</cod></p>

<ul>
<form><fieldset>
<legend>レポート自己チェックリスト</legend>
<input type="checkbox">考察を載せた.<br>
<input type="checkbox">文献情報(著者名, 図書名, 出版社, 出版年, ページ範囲)を載せた.<br>
<input type="checkbox">ネット調査の場合, URL, ソース, 実行結果を載せた.<br>

</fieldset></form></ul>

<!-- <li>課題3,4の学級クラスに, 高専生のソートメソッドを追加せよ. ソートのキーやアルゴリズムは自由に決めて良い. どうしても作成できない場合は, どこをどのように改造したらできそうか, 可能な限り<em>具体的</em>に検討して文章でまとめよ. (追加・変更箇所のソース, 解説, 実行結果, 考察をレポート)</li> -->

</ol>

<h3>レポート</h3>

<ul>
<li>内容: 課題中に指示されている通り. 必要な項目を全て記載しているか, 十分に確認すること.</li>
</ul>



</body></html>